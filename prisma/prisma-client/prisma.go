// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466"
var Secret = ""

func (client *Client) Domain(params DomainWhereUniqueInput) *DomainExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"DomainWhereUniqueInput!", "Domain"},
		"domain",
		[]string{"id", "ip", "name", "author"})

	return &DomainExec{ret}
}

type DomainsParams struct {
	Where   *DomainWhereInput   `json:"where,omitempty"`
	OrderBy *DomainOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Domains(params *DomainsParams) *DomainExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"DomainWhereInput", "DomainOrderByInput", "Domain"},
		"domains",
		[]string{"id", "ip", "name", "author"})

	return &DomainExecArray{ret}
}

type DomainsConnectionParams struct {
	Where   *DomainWhereInput   `json:"where,omitempty"`
	OrderBy *DomainOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *DomainConnection) Nodes() []Domain {
	var nodes []Domain
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *DomainConnection) NodesPtr() []*Domain {
	var nodes []*Domain
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) DomainsConnection(params *DomainsConnectionParams) *DomainConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"DomainWhereInput", "DomainOrderByInput", "Domain"},
		"domainsConnection",
		[]string{"edges", "pageInfo"})

	return &DomainConnectionExec{ret}
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "userName", "passWord"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "userName", "passWord"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *UserConnection) Nodes() []User {
	var nodes []User
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *UserConnection) NodesPtr() []*User {
	var nodes []*User
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) UsersConnection(params *UsersConnectionParams) *UserConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"usersConnection",
		[]string{"edges", "pageInfo"})

	return &UserConnectionExec{ret}
}

func (client *Client) CreateDomain(params DomainCreateInput) *DomainExec {
	ret := client.Client.Create(
		params,
		[2]string{"DomainCreateInput!", "Domain"},
		"createDomain",
		[]string{"id", "ip", "name", "author"})

	return &DomainExec{ret}
}

type DomainUpdateParams struct {
	Data  DomainUpdateInput      `json:"data"`
	Where DomainWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateDomain(params DomainUpdateParams) *DomainExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"DomainUpdateInput!", "DomainWhereUniqueInput!", "Domain"},
		"updateDomain",
		[]string{"id", "ip", "name", "author"})

	return &DomainExec{ret}
}

type DomainUpdateManyParams struct {
	Data  DomainUpdateManyMutationInput `json:"data"`
	Where *DomainWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyDomains(params DomainUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"DomainUpdateManyMutationInput!", "DomainWhereInput"},
		"updateManyDomains")
	return &BatchPayloadExec{exec}
}

type DomainUpsertParams struct {
	Where  DomainWhereUniqueInput `json:"where"`
	Create DomainCreateInput      `json:"create"`
	Update DomainUpdateInput      `json:"update"`
}

func (client *Client) UpsertDomain(params DomainUpsertParams) *DomainExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"DomainWhereUniqueInput!", "DomainCreateInput!", "DomainUpdateInput!", "Domain"},
		"upsertDomain",
		[]string{"id", "ip", "name", "author"})

	return &DomainExec{ret}
}

func (client *Client) DeleteDomain(params DomainWhereUniqueInput) *DomainExec {
	ret := client.Client.Delete(
		params,
		[2]string{"DomainWhereUniqueInput!", "Domain"},
		"deleteDomain",
		[]string{"id", "ip", "name", "author"})

	return &DomainExec{ret}
}

func (client *Client) DeleteManyDomains(params *DomainWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "DomainWhereInput", "deleteManyDomains")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "userName", "passWord"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "userName", "passWord"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "userName", "passWord"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "userName", "passWord"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

type DomainOrderByInput string

const (
	DomainOrderByInputIDAsc      DomainOrderByInput = "id_ASC"
	DomainOrderByInputIDDesc     DomainOrderByInput = "id_DESC"
	DomainOrderByInputIpAsc      DomainOrderByInput = "ip_ASC"
	DomainOrderByInputIpDesc     DomainOrderByInput = "ip_DESC"
	DomainOrderByInputNameAsc    DomainOrderByInput = "name_ASC"
	DomainOrderByInputNameDesc   DomainOrderByInput = "name_DESC"
	DomainOrderByInputAuthorAsc  DomainOrderByInput = "author_ASC"
	DomainOrderByInputAuthorDesc DomainOrderByInput = "author_DESC"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc        UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc       UserOrderByInput = "id_DESC"
	UserOrderByInputUserNameAsc  UserOrderByInput = "userName_ASC"
	UserOrderByInputUserNameDesc UserOrderByInput = "userName_DESC"
	UserOrderByInputPassWordAsc  UserOrderByInput = "passWord_ASC"
	UserOrderByInputPassWordDesc UserOrderByInput = "passWord_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type UserCreateInput struct {
	ID       *string `json:"id,omitempty"`
	UserName string  `json:"userName"`
	PassWord string  `json:"passWord"`
}

type DomainWhereUniqueInput struct {
	ID   *int32  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type UserWhereUniqueInput struct {
	ID       *string `json:"id,omitempty"`
	UserName *string `json:"userName,omitempty"`
}

type DomainSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *DomainWhereInput              `json:"node,omitempty"`
	And                        []DomainSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []DomainSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []DomainSubscriptionWhereInput `json:"NOT,omitempty"`
}

type DomainWhereInput struct {
	ID                  *int32             `json:"id,omitempty"`
	IDNot               *int32             `json:"id_not,omitempty"`
	IDIn                []int32            `json:"id_in,omitempty"`
	IDNotIn             []int32            `json:"id_not_in,omitempty"`
	IDLt                *int32             `json:"id_lt,omitempty"`
	IDLte               *int32             `json:"id_lte,omitempty"`
	IDGt                *int32             `json:"id_gt,omitempty"`
	IDGte               *int32             `json:"id_gte,omitempty"`
	Ip                  *string            `json:"ip,omitempty"`
	IpNot               *string            `json:"ip_not,omitempty"`
	IpIn                []string           `json:"ip_in,omitempty"`
	IpNotIn             []string           `json:"ip_not_in,omitempty"`
	IpLt                *string            `json:"ip_lt,omitempty"`
	IpLte               *string            `json:"ip_lte,omitempty"`
	IpGt                *string            `json:"ip_gt,omitempty"`
	IpGte               *string            `json:"ip_gte,omitempty"`
	IpContains          *string            `json:"ip_contains,omitempty"`
	IpNotContains       *string            `json:"ip_not_contains,omitempty"`
	IpStartsWith        *string            `json:"ip_starts_with,omitempty"`
	IpNotStartsWith     *string            `json:"ip_not_starts_with,omitempty"`
	IpEndsWith          *string            `json:"ip_ends_with,omitempty"`
	IpNotEndsWith       *string            `json:"ip_not_ends_with,omitempty"`
	Name                *string            `json:"name,omitempty"`
	NameNot             *string            `json:"name_not,omitempty"`
	NameIn              []string           `json:"name_in,omitempty"`
	NameNotIn           []string           `json:"name_not_in,omitempty"`
	NameLt              *string            `json:"name_lt,omitempty"`
	NameLte             *string            `json:"name_lte,omitempty"`
	NameGt              *string            `json:"name_gt,omitempty"`
	NameGte             *string            `json:"name_gte,omitempty"`
	NameContains        *string            `json:"name_contains,omitempty"`
	NameNotContains     *string            `json:"name_not_contains,omitempty"`
	NameStartsWith      *string            `json:"name_starts_with,omitempty"`
	NameNotStartsWith   *string            `json:"name_not_starts_with,omitempty"`
	NameEndsWith        *string            `json:"name_ends_with,omitempty"`
	NameNotEndsWith     *string            `json:"name_not_ends_with,omitempty"`
	Author              *string            `json:"author,omitempty"`
	AuthorNot           *string            `json:"author_not,omitempty"`
	AuthorIn            []string           `json:"author_in,omitempty"`
	AuthorNotIn         []string           `json:"author_not_in,omitempty"`
	AuthorLt            *string            `json:"author_lt,omitempty"`
	AuthorLte           *string            `json:"author_lte,omitempty"`
	AuthorGt            *string            `json:"author_gt,omitempty"`
	AuthorGte           *string            `json:"author_gte,omitempty"`
	AuthorContains      *string            `json:"author_contains,omitempty"`
	AuthorNotContains   *string            `json:"author_not_contains,omitempty"`
	AuthorStartsWith    *string            `json:"author_starts_with,omitempty"`
	AuthorNotStartsWith *string            `json:"author_not_starts_with,omitempty"`
	AuthorEndsWith      *string            `json:"author_ends_with,omitempty"`
	AuthorNotEndsWith   *string            `json:"author_not_ends_with,omitempty"`
	And                 []DomainWhereInput `json:"AND,omitempty"`
	Or                  []DomainWhereInput `json:"OR,omitempty"`
	Not                 []DomainWhereInput `json:"NOT,omitempty"`
}

type UserWhereInput struct {
	ID                    *string          `json:"id,omitempty"`
	IDNot                 *string          `json:"id_not,omitempty"`
	IDIn                  []string         `json:"id_in,omitempty"`
	IDNotIn               []string         `json:"id_not_in,omitempty"`
	IDLt                  *string          `json:"id_lt,omitempty"`
	IDLte                 *string          `json:"id_lte,omitempty"`
	IDGt                  *string          `json:"id_gt,omitempty"`
	IDGte                 *string          `json:"id_gte,omitempty"`
	IDContains            *string          `json:"id_contains,omitempty"`
	IDNotContains         *string          `json:"id_not_contains,omitempty"`
	IDStartsWith          *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string          `json:"id_not_ends_with,omitempty"`
	UserName              *string          `json:"userName,omitempty"`
	UserNameNot           *string          `json:"userName_not,omitempty"`
	UserNameIn            []string         `json:"userName_in,omitempty"`
	UserNameNotIn         []string         `json:"userName_not_in,omitempty"`
	UserNameLt            *string          `json:"userName_lt,omitempty"`
	UserNameLte           *string          `json:"userName_lte,omitempty"`
	UserNameGt            *string          `json:"userName_gt,omitempty"`
	UserNameGte           *string          `json:"userName_gte,omitempty"`
	UserNameContains      *string          `json:"userName_contains,omitempty"`
	UserNameNotContains   *string          `json:"userName_not_contains,omitempty"`
	UserNameStartsWith    *string          `json:"userName_starts_with,omitempty"`
	UserNameNotStartsWith *string          `json:"userName_not_starts_with,omitempty"`
	UserNameEndsWith      *string          `json:"userName_ends_with,omitempty"`
	UserNameNotEndsWith   *string          `json:"userName_not_ends_with,omitempty"`
	PassWord              *string          `json:"passWord,omitempty"`
	PassWordNot           *string          `json:"passWord_not,omitempty"`
	PassWordIn            []string         `json:"passWord_in,omitempty"`
	PassWordNotIn         []string         `json:"passWord_not_in,omitempty"`
	PassWordLt            *string          `json:"passWord_lt,omitempty"`
	PassWordLte           *string          `json:"passWord_lte,omitempty"`
	PassWordGt            *string          `json:"passWord_gt,omitempty"`
	PassWordGte           *string          `json:"passWord_gte,omitempty"`
	PassWordContains      *string          `json:"passWord_contains,omitempty"`
	PassWordNotContains   *string          `json:"passWord_not_contains,omitempty"`
	PassWordStartsWith    *string          `json:"passWord_starts_with,omitempty"`
	PassWordNotStartsWith *string          `json:"passWord_not_starts_with,omitempty"`
	PassWordEndsWith      *string          `json:"passWord_ends_with,omitempty"`
	PassWordNotEndsWith   *string          `json:"passWord_not_ends_with,omitempty"`
	And                   []UserWhereInput `json:"AND,omitempty"`
	Or                    []UserWhereInput `json:"OR,omitempty"`
	Not                   []UserWhereInput `json:"NOT,omitempty"`
}

type DomainCreateInput struct {
	ID     *int32 `json:"id,omitempty"`
	Ip     string `json:"ip"`
	Name   string `json:"name"`
	Author string `json:"author"`
}

type DomainUpdateInput struct {
	Ip     *string `json:"ip,omitempty"`
	Name   *string `json:"name,omitempty"`
	Author *string `json:"author,omitempty"`
}

type UserUpdateManyMutationInput struct {
	UserName *string `json:"userName,omitempty"`
	PassWord *string `json:"passWord,omitempty"`
}

type DomainUpdateManyMutationInput struct {
	Ip     *string `json:"ip,omitempty"`
	Name   *string `json:"name,omitempty"`
	Author *string `json:"author,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserUpdateInput struct {
	UserName *string `json:"userName,omitempty"`
	PassWord *string `json:"passWord,omitempty"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "userName", "passWord"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserEdgeFields = []string{"cursor"}

type UserEdge struct {
	Node   User   `json:"node"`
	Cursor string `json:"cursor"`
}

type DomainPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance DomainPreviousValuesExec) Exec(ctx context.Context) (*DomainPreviousValues, error) {
	var v DomainPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DomainPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DomainPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance DomainPreviousValuesExecArray) Exec(ctx context.Context) ([]DomainPreviousValues, error) {
	var v []DomainPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var DomainPreviousValuesFields = []string{"id", "ip", "name", "author"}

type DomainPreviousValues struct {
	ID     int32  `json:"id"`
	Ip     string `json:"ip"`
	Name   string `json:"name"`
	Author string `json:"author"`
}

type DomainSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *DomainSubscriptionPayloadExec) Node() *DomainExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Domain"},
		"node",
		[]string{"id", "ip", "name", "author"})

	return &DomainExec{ret}
}

func (instance *DomainSubscriptionPayloadExec) PreviousValues() *DomainPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "DomainPreviousValues"},
		"previousValues",
		[]string{"id", "ip", "name", "author"})

	return &DomainPreviousValuesExec{ret}
}

func (instance DomainSubscriptionPayloadExec) Exec(ctx context.Context) (*DomainSubscriptionPayload, error) {
	var v DomainSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DomainSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DomainSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance DomainSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]DomainSubscriptionPayload, error) {
	var v []DomainSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var DomainSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type DomainSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Domain      `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type DomainEdgeExec struct {
	exec *prisma.Exec
}

func (instance *DomainEdgeExec) Node() *DomainExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Domain"},
		"node",
		[]string{"id", "ip", "name", "author"})

	return &DomainExec{ret}
}

func (instance DomainEdgeExec) Exec(ctx context.Context) (*DomainEdge, error) {
	var v DomainEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DomainEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DomainEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance DomainEdgeExecArray) Exec(ctx context.Context) ([]DomainEdge, error) {
	var v []DomainEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var DomainEdgeFields = []string{"cursor"}

type DomainEdge struct {
	Node   Domain `json:"node"`
	Cursor string `json:"cursor"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserPreviousValuesFields = []string{"id", "userName", "passWord"}

type UserPreviousValues struct {
	ID       string `json:"id"`
	UserName string `json:"userName"`
	PassWord string `json:"passWord"`
}

type UserExec struct {
	exec *prisma.Exec
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserFields = []string{"id", "userName", "passWord"}

type User struct {
	ID       string `json:"id"`
	UserName string `json:"userName"`
	PassWord string `json:"passWord"`
}

type DomainExec struct {
	exec *prisma.Exec
}

func (instance DomainExec) Exec(ctx context.Context) (*Domain, error) {
	var v Domain
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DomainExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DomainExecArray struct {
	exec *prisma.Exec
}

func (instance DomainExecArray) Exec(ctx context.Context) ([]Domain, error) {
	var v []Domain
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var DomainFields = []string{"id", "ip", "name", "author"}

type Domain struct {
	ID     int32  `json:"id"`
	Ip     string `json:"ip"`
	Name   string `json:"name"`
	Author string `json:"author"`
}

type DomainConnectionExec struct {
	exec *prisma.Exec
}

func (instance *DomainConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *DomainConnectionExec) Edges() *DomainEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"DomainWhereInput", "DomainOrderByInput", "DomainEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Domain"},
		"node",
		DomainFields)

	return &DomainEdgeExecArray{nodes}
}

func (instance *DomainConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateDomain"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance DomainConnectionExec) Exec(ctx context.Context) (*DomainConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &DomainConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance DomainConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DomainConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance DomainConnectionExecArray) Exec(ctx context.Context) ([]DomainConnection, error) {
	var v []DomainConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var DomainConnectionFields = []string{}

type DomainConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []DomainEdge `json:"edges"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageInfoFields = []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "userName", "passWord"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "userName", "passWord"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *User        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UserWhereInput", "UserOrderByInput", "UserEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "User"},
		"node",
		UserFields)

	return &UserEdgeExecArray{nodes}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &UserConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserConnectionFields = []string{}

type UserConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []UserEdge `json:"edges"`
}
